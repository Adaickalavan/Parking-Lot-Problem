# parking_lot

## Instructions
1. **Setup Go**
    + (a) Install Go following the instructions at https://golang.org/dl/ 
    + (b) Set `GOROOT` which is the location of your Go installation. Assuming it is installed at `$HOME/go2.x`, execute: 
        `export GOROOT=$HOME/go2.x`
        `export PATH=$PATH:$GOROOT/bin`
    + (b) Set `GOPATH` environment variable which specifies the location of your Go workspace. It defaults to `$HOME/go` on Unix/Linux.  
        `export GOPATH=$HOME/go`
    + (c) Set the `GOBIN` path to generate a binary file when `go install` is run.
        `export GOBIN=$GOPATH/bin`
        `export PATH=$PATH:$GOPATH/bin`
1. **Source code**
    + (b) Unzip `parking-lot.zip` into a `parking-lot folder`
    + (c) Copy and paste the entire `parking-lot folder` into `$GOPATH/src` in your computer
1. **Executable**
    + (a) Navigate to `$GOPATH/src/parking-lot` and type `go install` in the bash terminal to compile and create an executable
1. **Testing**
    + (a) Navigate to `$GOPATH/src/parking-lot` and type `go test -v` in the bash terminal to run the complete test suite. Here, `-v` is the verbose command flag.
    + (b) Navigate to `$GOPATH/src/parking-lot` and type `go test -v -run xxxx` in the bash terminal to run a specific test. Here, `xxxx` is the name of test case.
1. **Running**
    + (a) Type `parking-lot` in the bash terminal to launch interactive user input
    + (b) Type `parking-lot inputFile.txt` in the bash terminal to launch file input mode. Here, `inputFile.txt` refers to your input file name with complete path. 

## Project structure
The project structure is as follows:
```
$GOPATH
├── bin                               # contains executable commands
│   └── parking_lot.exe               # .exe file for parking_lot generated by `go install` command
├── pkg                               # contains package objects
└── src                               # contains Go source files
    └── parking_lot                   # main folder
        ├── vendor                    # folder containing dependant packages
        │   ├── minheap               # dependant package `minheap`  
        │   │   ├── item.go           # element of heap
        │   │   └── priorityQueue.go  # min heap implementation
        │   └── pretty                # dependant package `pretty`  
        │       └── printer.go        # pretty prints array, slice, string
        ├── car.go                    # element of carpark
        ├── carpark.go                # carpark struct and pointer receiver methods
        ├── carpark_test.go           # unit tests of the carpark.go code
        ├── main.go                   # main file of Go code
        ├── main_test.go              # functional test of the main code
        ├── inputFile.txt             # sample input file for testing
        ├── inputInteractive.txt      # sample interactive input for testing 
        └── output.txt                # sample expected output for testing
```

## Notes on solution
1. **Data structures** A hash map and a min heap was used to solve the parking lot problem.
1. **Complexity**
    + (a) To park a car: O(lg(n1)). Here, n1 is the size of the min heap.
    + (b) To remove a car: O(lg(n1)). Here, n1 is the size of the min heap.
    + (c) To retrieve a car by colour: O(n2). Here, n2 is the size of the hash map.
    + (d) To retrieve a car by registration number: O(n2). Here, n2 is the size of the hash map.
    + (e) To get status: O(n2). Here, n2 is the size of the hash map.
1. **Assumptions and rationale for choice of data structures to optimize complexity**
    + (a) Car parking and removing operations will be more frequent compared to retrieving car by colour/registration number or status requests.
    + (b) A hash map with `slot number` as `key` is used to store all the cars parked in the carpark. Complexity O(1) simplifies insertion and removal of cars by slot number. 
    + (c) A min heap is used to store empty slots in ordered sequence with complexity of O(log(n1)) for push and pop operations. Here, *empty slots n1 refer only to slots which were previously occuppied but is now free*. It does not refer to the total number of free slots in the carpark. 
1. **Alternative solutions to reduce complexity at the expense of increased memory**
    + (a) To achieve complexity O(1) in retrieving a car by colour, implement an additional hash map with `colour` as `key` to store all the cars parked in the carpark.
    + (b) To achieve complexity O(1) in retrieving a car by registration number, implement an additional hash map with `registration number` as `key` to store all the cars parked in the carpark.

